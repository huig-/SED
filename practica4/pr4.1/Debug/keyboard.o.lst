   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"keyboard.c"
  21              	.Ltext0:
  22              		.file 1 "../keyboard.c"
 1911              		.align	2
 1914              	keyboard_base:
 1915 0000 00000006 		.word	100663296
 1916              		.comm	key,4,4
 1917              		.text
 1918              		.align	2
 1919              		.global	keyboard_init
 1921              	keyboard_init:
 1922              	.LFB0:
   1:../keyboard.c **** /*--- Ficheros de cabecera ---*/
   2:../keyboard.c **** #include "44b.h"
   3:../keyboard.c **** //#include "44blib.h"
   4:../keyboard.c **** #include "def.h"
   5:../keyboard.c **** /*--- Definición de macros ---*/
   6:../keyboard.c **** #define KEY_VALUE_MASK 0xF
   7:../keyboard.c **** /*--- Variables globales ---*/
   8:../keyboard.c **** volatile UCHAR *keyboard_base = (UCHAR *)0x06000000;
   9:../keyboard.c **** int key;
  10:../keyboard.c **** /*--- Funciones externas ---*/
  11:../keyboard.c **** void D8Led_symbol(int value);
  12:../keyboard.c **** /*--- Declaracion de funciones ---*/
  13:../keyboard.c **** void keyboard_init();
  14:../keyboard.c **** void KeyboardInt(void) __attribute__ ((interrupt ("IRQ")));
  15:../keyboard.c **** int key_read();
  16:../keyboard.c **** /*--- Codigo de las funciones ---*/
  17:../keyboard.c **** void keyboard_init()
  18:../keyboard.c **** {
 1923              		.loc 1 18 0
 1924              		.cfi_startproc
 1925              		@ Function supports interworking.
 1926              		@ args = 0, pretend = 0, frame = 0
 1927              		@ frame_needed = 1, uses_anonymous_args = 0
 1928 0000 0DC0A0E1 		mov	ip, sp
 1929              	.LCFI0:
 1930              		.cfi_def_cfa_register 12
 1931 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 1932 0008 04B04CE2 		sub	fp, ip, #4
 1933              		.cfi_offset 14, -8
 1934              		.cfi_offset 13, -12
 1935              		.cfi_offset 11, -16
 1936              	.LCFI1:
 1937              		.cfi_def_cfa 11, 4
  19:../keyboard.c **** 	/* Configurar el puerto G (si no lo estuviese ya) */	
  20:../keyboard.c **** 		// Establece la funcion de los pines (EINT0-7)
  21:../keyboard.c **** 	rPCONG = rPCONG | 0xC;
 1938              		.loc 1 21 0
 1939 000c 78309FE5 		ldr	r3, .L2
 1940 0010 74209FE5 		ldr	r2, .L2
 1941 0014 002092E5 		ldr	r2, [r2, #0]
 1942 0018 0C2082E3 		orr	r2, r2, #12
 1943 001c 002083E5 		str	r2, [r3, #0]
  22:../keyboard.c **** 		// Habilita el "pull up" del puerto
  23:../keyboard.c **** 	rPUPG = 0x0;
 1944              		.loc 1 23 0
 1945 0020 68309FE5 		ldr	r3, .L2+4
 1946 0024 0020A0E3 		mov	r2, #0
 1947 0028 002083E5 		str	r2, [r3, #0]
  24:../keyboard.c **** 		// Configura las lineas de int. como de flanco de bajada mediante EXTINT
  25:../keyboard.c **** 	rEXTINT = 0x22222222;
 1948              		.loc 1 25 0
 1949 002c 60309FE5 		ldr	r3, .L2+8
 1950 0030 60209FE5 		ldr	r2, .L2+12
 1951 0034 002083E5 		str	r2, [r3, #0]
  26:../keyboard.c **** 	/* Establece la rutina de servicio para EINT1 */
  27:../keyboard.c **** 	pISR_EINT1 = (unsigned)KeyboardInt;
 1952              		.loc 1 27 0
 1953 0038 5C309FE5 		ldr	r3, .L2+16
 1954 003c 5C209FE5 		ldr	r2, .L2+20
 1955 0040 002083E5 		str	r2, [r3, #0]
  28:../keyboard.c **** 	/* Configurar controlador de interrupciones */
  29:../keyboard.c **** 		// Borra INTPND escribiendo 1s en I_ISPC
  30:../keyboard.c **** 	rI_ISPC = 0x3ffffff;
 1956              		.loc 1 30 0
 1957 0044 58309FE5 		ldr	r3, .L2+24
 1958 0048 3F23E0E3 		mvn	r2, #-67108864
 1959 004c 002083E5 		str	r2, [r3, #0]
  31:../keyboard.c **** 		// Configura las lineas como de tipo IRQ mediante INTMOD
  32:../keyboard.c **** 	rINTMOD = 0x0;
 1960              		.loc 1 32 0
 1961 0050 50309FE5 		ldr	r3, .L2+28
 1962 0054 0020A0E3 		mov	r2, #0
 1963 0058 002083E5 		str	r2, [r3, #0]
  33:../keyboard.c **** 		// Habilita int. vectorizadas y la linea IRQ (FIQ no) mediante INTCON
  34:../keyboard.c **** 	rINTCON = 0x1;
 1964              		.loc 1 34 0
 1965 005c 1E36A0E3 		mov	r3, #31457280
 1966 0060 0120A0E3 		mov	r2, #1
 1967 0064 002083E5 		str	r2, [r3, #0]
  35:../keyboard.c **** 	/* Habilitar linea EINT1 */
  36:../keyboard.c **** 	rINTMSK = ~(BIT_EINT1 | BIT_GLOBAL);
 1968              		.loc 1 36 0
 1969 0068 3C309FE5 		ldr	r3, .L2+32
 1970 006c 0524E0E3 		mvn	r2, #83886080
 1971 0070 002083E5 		str	r2, [r3, #0]
  37:../keyboard.c **** 	/* Por precaucion, se vuelven a borrar los bits de INTPND correspondientes*/
  38:../keyboard.c **** 	rI_ISPC = 0x3ffffff;
 1972              		.loc 1 38 0
 1973 0074 28309FE5 		ldr	r3, .L2+24
 1974 0078 3F23E0E3 		mvn	r2, #-67108864
 1975 007c 002083E5 		str	r2, [r3, #0]
  39:../keyboard.c **** }
 1976              		.loc 1 39 0
 1977 0080 0CD04BE2 		sub	sp, fp, #12
 1978 0084 00689DE8 		ldmfd	sp, {fp, sp, lr}
 1979 0088 1EFF2FE1 		bx	lr
 1980              	.L3:
 1981              		.align	2
 1982              	.L2:
 1983 008c 4000D201 		.word	30539840
 1984 0090 4800D201 		.word	30539848
 1985 0094 5000D201 		.word	30539856
 1986 0098 22222222 		.word	572662306
 1987 009c 80FF7F0C 		.word	209715072
 1988 00a0 00000000 		.word	KeyboardInt
 1989 00a4 2400E001 		.word	31457316
 1990 00a8 0800E001 		.word	31457288
 1991 00ac 0C00E001 		.word	31457292
 1992              		.cfi_endproc
 1993              	.LFE0:
 1995              		.align	2
 1996              		.global	KeyboardInt
 1998              	KeyboardInt:
 1999              	.LFB1:
  40:../keyboard.c **** void KeyboardInt(void)
  41:../keyboard.c **** {
 2000              		.loc 1 41 0
 2001              		.cfi_startproc
 2002              		@ Interrupt Service Routine.
 2003              		@ args = 0, pretend = 0, frame = 0
 2004              		@ frame_needed = 1, uses_anonymous_args = 0
 2005 00b0 04C02DE5 		str	ip, [sp, #-4]!
 2006 00b4 0DC0A0E1 		mov	ip, sp
 2007              	.LCFI2:
 2008              		.cfi_def_cfa_register 12
 2009 00b8 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 2010 00bc 04B04CE2 		sub	fp, ip, #4
 2011              		.cfi_offset 14, -8
 2012              		.cfi_offset 13, -12
 2013              		.cfi_offset 11, -16
 2014              		.cfi_offset 3, -20
 2015              		.cfi_offset 2, -24
 2016              		.cfi_offset 1, -28
 2017              		.cfi_offset 0, -32
 2018              	.LCFI3:
 2019              		.cfi_def_cfa 11, 4
  42:../keyboard.c **** 	/* Esperar trp mediante la funcion DelayMs()*/
  43:../keyboard.c **** 	DelayMs(20);
 2020              		.loc 1 43 0
 2021 00c0 1400A0E3 		mov	r0, #20
 2022 00c4 FEFFFFEB 		bl	DelayMs
  44:../keyboard.c **** 	/* Identificar la tecla */
  45:../keyboard.c **** 	key = key_read();
 2023              		.loc 1 45 0
 2024 00c8 FEFFFFEB 		bl	key_read
 2025 00cc 0020A0E1 		mov	r2, r0
 2026 00d0 3C309FE5 		ldr	r3, .L6
 2027 00d4 002083E5 		str	r2, [r3, #0]
  46:../keyboard.c **** 	/* Si la tecla se ha identificado, visualizarla en el 8SEG*/
  47:../keyboard.c **** 	if(key > -1)
  48:../keyboard.c **** 	{
  49:../keyboard.c **** 		// D8Led_symbol(key);
  50:../keyboard.c **** 	}
  51:../keyboard.c **** 	/* Esperar a se libere la tecla: consultar bit 1 del registro de datos del puerto G */
  52:../keyboard.c **** 	while ((rPDATG & (0x1<<1)) == 0);
 2028              		.loc 1 52 0
 2029 00d8 0000A0E1 		mov	r0, r0	@ nop
 2030              	.L5:
 2031              		.loc 1 52 0 is_stmt 0 discriminator 1
 2032 00dc 34309FE5 		ldr	r3, .L6+4
 2033 00e0 003093E5 		ldr	r3, [r3, #0]
 2034 00e4 023003E2 		and	r3, r3, #2
 2035 00e8 000053E3 		cmp	r3, #0
 2036 00ec FAFFFF0A 		beq	.L5
  53:../keyboard.c **** 	/* Esperar trd mediante la funcion Delay() */
  54:../keyboard.c **** 	DelayMs(100);
 2037              		.loc 1 54 0 is_stmt 1
 2038 00f0 6400A0E3 		mov	r0, #100
 2039 00f4 FEFFFFEB 		bl	DelayMs
  55:../keyboard.c **** 	/* Borrar interrupción de teclado */
  56:../keyboard.c **** 	rI_ISPC = BIT_EINT1;
 2040              		.loc 1 56 0
 2041 00f8 1C309FE5 		ldr	r3, .L6+8
 2042 00fc 0124A0E3 		mov	r2, #16777216
 2043 0100 002083E5 		str	r2, [r3, #0]
  57:../keyboard.c **** }
 2044              		.loc 1 57 0
 2045 0104 1CD04BE2 		sub	sp, fp, #28
 2046 0108 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 2047 010c 04C09DE4 		ldmfd	sp!, {ip}
 2048 0110 04F05EE2 		subs	pc, lr, #4
 2049              	.L7:
 2050              		.align	2
 2051              	.L6:
 2052 0114 00000000 		.word	key
 2053 0118 4400D201 		.word	30539844
 2054 011c 2400E001 		.word	31457316
 2055              		.cfi_endproc
 2056              	.LFE1:
 2058              		.align	2
 2059              		.global	key_read
 2061              	key_read:
 2062              	.LFB2:
  58:../keyboard.c **** 
  59:../keyboard.c **** int key_read()
  60:../keyboard.c **** {
 2063              		.loc 1 60 0
 2064              		.cfi_startproc
 2065              		@ Function supports interworking.
 2066              		@ args = 0, pretend = 0, frame = 8
 2067              		@ frame_needed = 1, uses_anonymous_args = 0
 2068 0120 0DC0A0E1 		mov	ip, sp
 2069              	.LCFI4:
 2070              		.cfi_def_cfa_register 12
 2071 0124 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2072 0128 04B04CE2 		sub	fp, ip, #4
 2073              		.cfi_offset 14, -8
 2074              		.cfi_offset 13, -12
 2075              		.cfi_offset 11, -16
 2076              	.LCFI5:
 2077              		.cfi_def_cfa 11, 4
 2078 012c 08D04DE2 		sub	sp, sp, #8
  61:../keyboard.c **** 	int value = -1;
 2079              		.loc 1 61 0
 2080 0130 0030E0E3 		mvn	r3, #0
 2081 0134 10300BE5 		str	r3, [fp, #-16]
  62:../keyboard.c **** 	char temp;
  63:../keyboard.c **** 	// Identificar la tecla mediante ''scanning''
  64:../keyboard.c **** 	// Si la identificación falla la función debe devolver -1
  65:../keyboard.c **** 	temp = *(keyboard_base + 0xfd) & KEY_VALUE_MASK; //Usamos KEY_VALUE_MASK para quedarnos con los 4 
 2082              		.loc 1 65 0
 2083 0138 0C329FE5 		ldr	r3, .L33
 2084 013c 003093E5 		ldr	r3, [r3, #0]
 2085 0140 FD3083E2 		add	r3, r3, #253
 2086 0144 0030D3E5 		ldrb	r3, [r3, #0]
 2087 0148 FF3003E2 		and	r3, r3, #255
 2088 014c 0F3003E2 		and	r3, r3, #15
 2089 0150 11304BE5 		strb	r3, [fp, #-17]
  66:../keyboard.c **** 
  67:../keyboard.c **** 	switch (temp) {
 2090              		.loc 1 67 0
 2091 0154 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2092 0158 073043E2 		sub	r3, r3, #7
 2093 015c 070053E3 		cmp	r3, #7
 2094 0160 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2095 0164 130000EA 		b	.L9
 2096              	.L14:
 2097 0168 88010000 		.word	.L10
 2098 016c B8010000 		.word	.L9
 2099 0170 B8010000 		.word	.L9
 2100 0174 B8010000 		.word	.L9
 2101 0178 94010000 		.word	.L11
 2102 017c B8010000 		.word	.L9
 2103 0180 A0010000 		.word	.L12
 2104 0184 AC010000 		.word	.L13
 2105              	.L10:
  68:../keyboard.c **** 		case 0x7:  value = 0 ; break;
 2106              		.loc 1 68 0
 2107 0188 0030A0E3 		mov	r3, #0
 2108 018c 10300BE5 		str	r3, [fp, #-16]
 2109 0190 080000EA 		b	.L9
 2110              	.L11:
  69:../keyboard.c **** 		case 0xB:  value = 1; break;
 2111              		.loc 1 69 0
 2112 0194 0130A0E3 		mov	r3, #1
 2113 0198 10300BE5 		str	r3, [fp, #-16]
 2114 019c 050000EA 		b	.L9
 2115              	.L12:
  70:../keyboard.c **** 		case 0xD:  value = 2; break;
 2116              		.loc 1 70 0
 2117 01a0 0230A0E3 		mov	r3, #2
 2118 01a4 10300BE5 		str	r3, [fp, #-16]
 2119 01a8 020000EA 		b	.L9
 2120              	.L13:
  71:../keyboard.c **** 		case 0xE:  value = 3; break;
 2121              		.loc 1 71 0
 2122 01ac 0330A0E3 		mov	r3, #3
 2123 01b0 10300BE5 		str	r3, [fp, #-16]
 2124 01b4 0000A0E1 		mov	r0, r0	@ nop
 2125              	.L9:
  72:../keyboard.c **** 	}
  73:../keyboard.c **** 	
  74:../keyboard.c **** 	/*
  75:../keyboard.c **** 	* ESCRIBIR EL CÓDIGO CORRESPONDIENTE A LAS OTRAS FILAS Y COLUMNAS
  76:../keyboard.c **** 	*/
  77:../keyboard.c **** 	temp = *(keyboard_base + 0xfb) & KEY_VALUE_MASK; //Usamos KEY_VALUE_MASK para quedarnos con los 4 
 2126              		.loc 1 77 0
 2127 01b8 8C319FE5 		ldr	r3, .L33
 2128 01bc 003093E5 		ldr	r3, [r3, #0]
 2129 01c0 FB3083E2 		add	r3, r3, #251
 2130 01c4 0030D3E5 		ldrb	r3, [r3, #0]
 2131 01c8 FF3003E2 		and	r3, r3, #255
 2132 01cc 0F3003E2 		and	r3, r3, #15
 2133 01d0 11304BE5 		strb	r3, [fp, #-17]
  78:../keyboard.c **** 
  79:../keyboard.c **** 	switch (temp) {
 2134              		.loc 1 79 0
 2135 01d4 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2136 01d8 073043E2 		sub	r3, r3, #7
 2137 01dc 070053E3 		cmp	r3, #7
 2138 01e0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2139 01e4 130000EA 		b	.L15
 2140              	.L20:
 2141 01e8 08020000 		.word	.L16
 2142 01ec 38020000 		.word	.L15
 2143 01f0 38020000 		.word	.L15
 2144 01f4 38020000 		.word	.L15
 2145 01f8 14020000 		.word	.L17
 2146 01fc 38020000 		.word	.L15
 2147 0200 20020000 		.word	.L18
 2148 0204 2C020000 		.word	.L19
 2149              	.L16:
  80:../keyboard.c **** 		case 0x7:  value = 4; break;
 2150              		.loc 1 80 0
 2151 0208 0430A0E3 		mov	r3, #4
 2152 020c 10300BE5 		str	r3, [fp, #-16]
 2153 0210 080000EA 		b	.L15
 2154              	.L17:
  81:../keyboard.c **** 		case 0xB:  value = 5; break;
 2155              		.loc 1 81 0
 2156 0214 0530A0E3 		mov	r3, #5
 2157 0218 10300BE5 		str	r3, [fp, #-16]
 2158 021c 050000EA 		b	.L15
 2159              	.L18:
  82:../keyboard.c **** 		case 0xD:  value = 6; break;
 2160              		.loc 1 82 0
 2161 0220 0630A0E3 		mov	r3, #6
 2162 0224 10300BE5 		str	r3, [fp, #-16]
 2163 0228 020000EA 		b	.L15
 2164              	.L19:
  83:../keyboard.c **** 		case 0xE:  value = 7; break;
 2165              		.loc 1 83 0
 2166 022c 0730A0E3 		mov	r3, #7
 2167 0230 10300BE5 		str	r3, [fp, #-16]
 2168 0234 0000A0E1 		mov	r0, r0	@ nop
 2169              	.L15:
  84:../keyboard.c **** 	}
  85:../keyboard.c **** 
  86:../keyboard.c **** 	temp = *(keyboard_base + 0xf7) & KEY_VALUE_MASK; //Usamos KEY_VALUE_MASK para quedarnos con los 4 
 2170              		.loc 1 86 0
 2171 0238 0C319FE5 		ldr	r3, .L33
 2172 023c 003093E5 		ldr	r3, [r3, #0]
 2173 0240 F73083E2 		add	r3, r3, #247
 2174 0244 0030D3E5 		ldrb	r3, [r3, #0]
 2175 0248 FF3003E2 		and	r3, r3, #255
 2176 024c 0F3003E2 		and	r3, r3, #15
 2177 0250 11304BE5 		strb	r3, [fp, #-17]
  87:../keyboard.c **** 
  88:../keyboard.c **** 	switch (temp) {
 2178              		.loc 1 88 0
 2179 0254 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2180 0258 073043E2 		sub	r3, r3, #7
 2181 025c 070053E3 		cmp	r3, #7
 2182 0260 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2183 0264 130000EA 		b	.L21
 2184              	.L26:
 2185 0268 88020000 		.word	.L22
 2186 026c B8020000 		.word	.L21
 2187 0270 B8020000 		.word	.L21
 2188 0274 B8020000 		.word	.L21
 2189 0278 94020000 		.word	.L23
 2190 027c B8020000 		.word	.L21
 2191 0280 A0020000 		.word	.L24
 2192 0284 AC020000 		.word	.L25
 2193              	.L22:
  89:../keyboard.c **** 		case 0x7:  value = 8; break;
 2194              		.loc 1 89 0
 2195 0288 0830A0E3 		mov	r3, #8
 2196 028c 10300BE5 		str	r3, [fp, #-16]
 2197 0290 080000EA 		b	.L21
 2198              	.L23:
  90:../keyboard.c **** 		case 0xB:  value = 9; break;
 2199              		.loc 1 90 0
 2200 0294 0930A0E3 		mov	r3, #9
 2201 0298 10300BE5 		str	r3, [fp, #-16]
 2202 029c 050000EA 		b	.L21
 2203              	.L24:
  91:../keyboard.c **** 		case 0xD:  value = 10; break;
 2204              		.loc 1 91 0
 2205 02a0 0A30A0E3 		mov	r3, #10
 2206 02a4 10300BE5 		str	r3, [fp, #-16]
 2207 02a8 020000EA 		b	.L21
 2208              	.L25:
  92:../keyboard.c **** 		case 0xE:  value = 11; break;
 2209              		.loc 1 92 0
 2210 02ac 0B30A0E3 		mov	r3, #11
 2211 02b0 10300BE5 		str	r3, [fp, #-16]
 2212 02b4 0000A0E1 		mov	r0, r0	@ nop
 2213              	.L21:
  93:../keyboard.c **** 	}
  94:../keyboard.c **** 
  95:../keyboard.c **** 	temp = *(keyboard_base + 0xef) & KEY_VALUE_MASK; //Usamos KEY_VALUE_MASK para quedarnos con los 4 
 2214              		.loc 1 95 0
 2215 02b8 8C309FE5 		ldr	r3, .L33
 2216 02bc 003093E5 		ldr	r3, [r3, #0]
 2217 02c0 EF3083E2 		add	r3, r3, #239
 2218 02c4 0030D3E5 		ldrb	r3, [r3, #0]
 2219 02c8 FF3003E2 		and	r3, r3, #255
 2220 02cc 0F3003E2 		and	r3, r3, #15
 2221 02d0 11304BE5 		strb	r3, [fp, #-17]
  96:../keyboard.c **** 
  97:../keyboard.c **** 	switch (temp) {
 2222              		.loc 1 97 0
 2223 02d4 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 2224 02d8 073043E2 		sub	r3, r3, #7
 2225 02dc 070053E3 		cmp	r3, #7
 2226 02e0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2227 02e4 130000EA 		b	.L27
 2228              	.L32:
 2229 02e8 08030000 		.word	.L28
 2230 02ec 38030000 		.word	.L27
 2231 02f0 38030000 		.word	.L27
 2232 02f4 38030000 		.word	.L27
 2233 02f8 14030000 		.word	.L29
 2234 02fc 38030000 		.word	.L27
 2235 0300 20030000 		.word	.L30
 2236 0304 2C030000 		.word	.L31
 2237              	.L28:
  98:../keyboard.c **** 		case 0x7:  value = 12; break;
 2238              		.loc 1 98 0
 2239 0308 0C30A0E3 		mov	r3, #12
 2240 030c 10300BE5 		str	r3, [fp, #-16]
 2241 0310 080000EA 		b	.L27
 2242              	.L29:
  99:../keyboard.c **** 		case 0xB:  value = 13; break;
 2243              		.loc 1 99 0
 2244 0314 0D30A0E3 		mov	r3, #13
 2245 0318 10300BE5 		str	r3, [fp, #-16]
 2246 031c 050000EA 		b	.L27
 2247              	.L30:
 100:../keyboard.c **** 		case 0xD:  value = 14; break;
 2248              		.loc 1 100 0
 2249 0320 0E30A0E3 		mov	r3, #14
 2250 0324 10300BE5 		str	r3, [fp, #-16]
 2251 0328 020000EA 		b	.L27
 2252              	.L31:
 101:../keyboard.c **** 		case 0xE:  value = 15; break;
 2253              		.loc 1 101 0
 2254 032c 0F30A0E3 		mov	r3, #15
 2255 0330 10300BE5 		str	r3, [fp, #-16]
 2256 0334 0000A0E1 		mov	r0, r0	@ nop
 2257              	.L27:
 102:../keyboard.c **** 	}
 103:../keyboard.c **** 
 104:../keyboard.c **** 	return value;
 2258              		.loc 1 104 0
 2259 0338 10301BE5 		ldr	r3, [fp, #-16]
 105:../keyboard.c **** 
 106:../keyboard.c **** }
 2260              		.loc 1 106 0
 2261 033c 0300A0E1 		mov	r0, r3
 2262 0340 0CD04BE2 		sub	sp, fp, #12
 2263 0344 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2264 0348 1EFF2FE1 		bx	lr
 2265              	.L34:
 2266              		.align	2
 2267              	.L33:
 2268 034c 00000000 		.word	keyboard_base
 2269              		.cfi_endproc
 2270              	.LFE2:
 2272              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 keyboard.c
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1914   .data:00000000 keyboard_base
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1911   .data:00000000 $d
                            *COM*:00000004 key
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1918   .text:00000000 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1921   .text:00000000 keyboard_init
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1983   .text:0000008c $d
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1998   .text:000000b0 KeyboardInt
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:1995   .text:000000b0 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2061   .text:00000120 key_read
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2052   .text:00000114 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2058   .text:00000120 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2097   .text:00000168 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2107   .text:00000188 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2141   .text:000001e8 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2151   .text:00000208 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2185   .text:00000268 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2195   .text:00000288 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2229   .text:000002e8 $d
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2239   .text:00000308 $a
C:\Users\USUARI~1\AppData\Local\Temp\ccQsxbqg.s:2268   .text:0000034c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
DelayMs
